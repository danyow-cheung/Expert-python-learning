# Deploying code 
如果不運行，即使是完美的代碼（如果存在的話）也是無用的。 
所以為了達到一個目的，我們的代碼需要安裝到目標機器（電腦）上並執行。 
使最終用戶可以使用特定版本的應用程序或服務的過程稱為**部署**。

令人驚訝的是，當您的代碼本身不是產品時，事情會變得更加複雜。 
如果您的應用程序僅提供出售給用戶的服務，那麼您有責任在自己的基礎架構上運行它。 
這種情況對於 Web 應用程序或任何“X 即服務”產品來說是典型的。 
在這種情況下，代碼被部署以啟動通常開發人員幾乎無法物理訪問的遠程機器。 


在本章中，由於 Python 在構建各種與 Web 相關的服務和產品領域非常受歡迎，因此我們將重點關注代碼部署到遠程主機方面。 
儘管這種語言具有很高的可移植性，但它沒有使其代碼易於部署的特定特性。 
最重要的是您的應用程序是如何構建的，以及您使用什麼流程將其部署到目標環境。 
因此，本章將重點關注以下主題：
- 將代碼部署到遠程環境的主要挑戰是什麼 
- 如何使用 Python 構建易於部署的應用程序
- 如何在不停機的情況下重新加載 Web 服務
- 如何在代碼部署中利用 Python 打包生態系統
- 如何正確監控和檢測遠程運行的代碼

## The Twelve-Factor App 
無痛部署的主要要求是以確保此過程盡可能簡單和流線型的方式構建您的應用程序。 
這主要是關於消除障礙和鼓勵行之有效的做法。 
在只有特定人員負責開發（開發人員團隊或簡稱 Dev）而不同人員負責部署和維護執行環境（運維團隊或簡稱 Ops）的組織中，遵循此類通用做法尤為重要。

所有與服務器維護、監控、部署、配置等相關的任務通常都放在一個稱為操作的包中。 
即使在沒有單獨的團隊來執行操作任務的組織中，**通常也只有一些開發人員被授權執行部署任務和維護遠程服務器。 這種職位的通用名稱是 DevOps**。 
此外，開發團隊的每個成員都負責運維的情況並不少見，因此這樣的團隊中的每個人都可以稱為 DevOps。 不管怎樣，不管你的組織結構如何，每個開發人員的職責是什麼，每個人都應該知道操作是如何工作的，代碼是如何部署到遠程服務器上的，因為說到底，執行環境及其配置是一個隱藏的部分 您正在構建的產品。


顧名思義，十二要素 App 由 12 條規則組成：
- 代碼庫：在修訂控制中跟踪一個代碼庫，許多部署
- 依賴項：顯式聲明和隔離依賴項
- Config：存放配置在環境中
- 支持服務：將支持服務視為附加資源構建、
- 發布、運行：嚴格分離
- 構建和運行階段進程：將應用程序作為一個或多個無狀態進程執行
- 端口綁定：通過端口綁定導出服務
- 並發性：通過流程模型橫向擴展
- 可處置性：通過快速啟動和優雅關閉最大限度地提高穩健性
- 開發/生產對等：使開發、暫存和生產盡可能相似
- 日誌：將日誌視為事件流
- 管理流程：將管理/管理任務作為一次性流程運行

## Deployment automation using Fabric 
對於非常小的項目，可以“手動”部署代碼，即通過遠程 shell 手動鍵入安裝新版本代碼並在遠程 shell 上執行所需的命令序列 . 
無論如何，即使對於一個中等規模的項目，這也容易出錯、乏味，並且應該被視為浪費您擁有的大部分寶貴資源，即您自己的時間。

解決方案是自動化。 簡單的經驗法則可能是，如果您需要至少手動執行同一任務兩次，則應該將其自動化，這樣您就不需要第三次執行它。 有多種工具可以讓您自動化不同的事情：
- Fabric 等遠程執行工具用於在多個遠程主機上按需自動執行代碼。
- Chef、Puppet、CFEngine、Salt 和 Ansible 等配置管理工具專為遠程主機（執行環境）的自動化配置而設計。 它們可用於設置支持服務（數據庫、緩存等）、系統權限、用戶等。 它們中的大多數也可以像 Fabric 一樣用作遠程執行的工具，但是根據它們的架構，這可能或多或少容易一些。


The truth is that the simplest remote execution frameworks have the lowest entry barrier and are the most popular choice,
事實上，最簡單的遠程執行框架具有最低的進入門檻，並且是最受歡迎的選擇，


## Your own package index or index mirror 
您可能想要運行自己的 Python 包索引的三個主要原因：
- 官方 Python 包索引不提供任何可用性保證。 由於大量捐贈，它由 Python 軟件基金會運營。 因此，這通常意味著該站點可能會關閉。 您不希望由於 PyPI 中斷而在中間停止部署或打包過程。
- 將用 Python 編寫的可重用組件正確打包是很有用的，即使對於永遠不會公開發布的封閉源代碼也是如此。 它簡化了代碼庫，因為不需要銷售在整個公司用於不同項目的包。 您可以簡單地從存儲庫安裝它們。 這簡化了此類共享代碼的維護，如果有許多團隊從事不同的項目，則可能會降低整個公司的開發成本。
- 使用 setuptools 打包整個項目是一個很好的做法。 然後，新應用程序版本的部署通常就像運行 pip install --update my-application 一樣簡單。

### PyPI mirroring 
PyPI 中斷的問題可以通過允許安裝工具從其鏡像之一下載包來以某種方式緩解。 
事實上，官方的 Python Package Index 已經通過 CDN（Content Delivery Network）提供服務，因此它本質上是鏡像的。
這並沒有改變這樣一個事實，即當任何嘗試下載包的嘗試失敗時，它似乎時不時會有一些糟糕的日子。 使用非官方鏡像不是這裡的解決方案，因為它可能會引起一些安全問題。

### Deployment using a package 
現代 web 應用程序有很多依賴關係，通常需要很多步驟才能在遠程主機上正確安裝。 例如，遠程主機上新版本應用程序的典型引導過程包括以下步驟：
- 新建隔離虛擬環境
- 將項目代碼移動到執行環境
- 安裝最新的項目需求（通常來自 requirements.txt 文件）
- 同步或遷移數據庫架構
- 從項目源和外部包中收集靜態文件到所需位置
- 為不同語言的應用程序編譯本地化文件

## Common conventions and practices 
有一組通用的部署約定和實踐，並不是每個開發人員都知道，但對於那些在他們的生活中做過一些操作的人來說是顯而易見的。 
正如章節介紹中所解釋的，即使您不負責代碼部署和操作，至少了解其中的一些也是至關重要的，因為這將使您在開發過程中做出更好的設計決策。

### The filesystem hierarchy
當然，在 Unix 和類 Unix 操作系統中有一個文件系統層次結構標準，它定義了目錄結構和目錄內容，但是很難找到一個完全符合 FHS 的實際操作系統發行版。

### Isolation
為每個版本創建新的環境有助於管理它們的干淨狀態並遵守提供的依賴項列表。 
所謂新環境，我們的意思是在文件系統中創建一個新的目錄樹，而不是更新已經存在的文件。 
不幸的是，這可能會使執行諸如優雅地重新加載服務之類的事情變得有點困難，如果就地更新環境，這將更容易實現。

### Using process supervision tools 
當然不可能在 shell 中手動運行它並擁有永無止境的 SSH 連接。 使用 nohup、screen 或 tmux 來半守護進程不是一個選項。 這樣做就像設計你的服務失敗。

您需要的是擁有一些可以啟動和管理您的申請流程的流程監督工具。 在選擇合適的之前，您需要確保：
- 如果退出則重新啟動服務
- 可靠地跟踪其狀態
- 捕獲其 stdout/stderr 流以用於日誌目的
- 運行具有特定用戶/組權限的進程配置系統環境變量

Python 社區中用於管理應用程序進程的兩個流行工具是 Supervisor (http://supervisord.org) 和 Circus

### Application code should be run in user space 
您的應用程序代碼應始終在用戶空間中運行。 這意味著它不能在超級用戶權限下執行。 如果您按照十二因素應用程序設計您的應用程序，則有可能在幾乎沒有權限的用戶下運行您的應用程序。 不擁有任何文件且不屬於任何特權組的用戶的常規名稱是 nobody，無論如何實際建議是為每個應用程序守護程序創建一個單獨的用戶。 

這樣做的原因是系統安全。 這是為了限制惡意用戶在獲得對您的應用程序進程的控制權後可能造成的損害。 在 Linux 中，同一用戶的進程可以相互交互，因此在用戶級別將不同的應用程序分開很重要。

### Using reverse HTTP proxies 
多個符合 Python WSGI 標準的 Web 服務器可以輕鬆地自行處理 HTTP 流量，而無需在它們之上安裝任何其他 Web 服務器。 由於各種原因，將它們隱藏在諸如 Nginx 之類的反向代理後面仍然很常見：
- TLS/SSL
- Unprivileged 
### Reloading process gracefully 

## Code instrumentation and monitoring 
### Logging errors - sentry/raven 
### Monitoring system and application metrics 
### Dealing with application logs 
#### Basic low-level log practices 
#### Tools for log processing 
