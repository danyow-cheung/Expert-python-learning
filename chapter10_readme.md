# Test-Driven Development
測試驅動開發 (TDD) 是一種生產高質量軟件的簡單技術。 它在 Python 社區中被廣泛使用，但在其他社區中也很受歡迎。

## I don't test
由於 Python 的動態特性，測試在 Python 中尤為重要。 它缺少靜態類型，因此在運行代碼並執行其每一行之前，許多甚至是微小的錯誤都不會被注意到。 但問題不僅在於 Python 中的類型如何工作。 請記住，大多數錯誤與錯誤的語法使用無關，而是與可能導致重大失敗的邏輯錯誤和微妙的誤解有關。

### Test-driven development principles 
以最簡單的形式，測試驅動開發過程包括三個步驟：
1. 為尚未實現的新功能或改進編寫自動化測試。
2. 提供剛好通過所有定義測試的最少代碼。 
3. 重構代碼以滿足所需的質量標準。
關於這個開發週期要記住的最重要的事實是測試應該在實現之前編寫。 對於沒有經驗的開發人員來說，這不是一件容易的事，但這是保證您將要編寫的代碼可測試的唯一方法。

測試驅動開發提供了很多好處：
- 它有助於防止軟件回歸
- 它提高了軟件質量
- 它提供了一種代碼行為的低級文檔
- 它允許您在較短的開發週期內更快地生成健壯的代碼
處理測試的最佳約定是將它們全部收集在一個模塊或包中（通常命名為測試），並有一種使用單個 shell 命令運行整個套件的簡單方法。 幸運的是，沒有必要自己構建整個測試工具鏈。 Python 標準庫和 Python Package Index 都帶有大量測試框架和實用程序，可讓您以方便的方式構建、發現和運行測試。 我們將在本章後面討論此類包和模塊的最著名示例。

#### Preventing software regression
在我們的開發人員生活中，我們都面臨著軟件回歸問題。 軟件回歸是由變更引入的新錯誤。 當已知在以前版本的軟件中工作的特性或功能在項目開發過程中的某個時刻被破壞並停止工作時，它就會出現。

回歸的主要原因是軟件的高度複雜性。 在某些時候，不可能猜測代碼庫中的單個更改可能導致什麼。 更改某些代碼可能會破壞其他一些功能，有時會導致惡性副作用，例如無聲地破壞數據。 而高複雜性不僅僅是龐大代碼庫的問題。 當然，代碼量與其複雜性之間存在明顯的相關性，但即使是小項目（幾百分之幾/幾千行代碼）也可能具有如此復雜的架構，以至於很難預測相對較小的變化的所有後果。

向多個開發人員開放代碼庫會放大問題，因為每個人都不會完全了解所有開發活動。 雖然擁有版本控制系統可以防止衝突，但它並不能防止所有不需要的交互。

TDD 有助於減少軟件回歸。 整個軟件可以在每次更改後自動測試。 只要每個功能都有適當的測試集，這就會起作用。 正確完成 TDD 後，測試庫會與代碼庫一起增長。

由於完整的測試活動可能會持續很長時間，因此最好將其委託給一些可以在後台完成工作的持續集成系統。 
#### Improving code quality
編寫新模塊、類或函數時，開發人員關注的是如何編寫它以及如何生成他或她所能編寫的最佳代碼。 但是當他或她專注於算法時，他或她可能會失去用戶的觀點：他或她的功能將如何以及何時被使用？ 這些論點是否易於使用且合乎邏輯？ API的名稱是否正確？
這是通過應用前面章節中描述的技巧來完成的，例如第 4 章，選擇好名字。 但唯一有效地做到這一點的方法是編寫使用示例。 這是開發人員意識到他或她編寫的代碼是否合乎邏輯且易於使用的時刻。 通常，第一次重構發生在模塊、類或函數完成之後。

#### Providing the best developer documentation
測試是開發人員了解軟件工作原理的最佳場所。 它們是代碼主要針對的用例。 閱讀它們可以快速深入地了解代碼的工作原理。 有時一個例子勝過一千個字。
事實上，這些測試始終與代碼庫保持同步，這使它們成為軟件可以擁有的最好的開發人員文檔。 測試不會像文檔那樣過時，否則它們會失敗。

#### Producing robust code faster 
未經測試而編寫會導致調試時間過長。 一個模塊中錯誤的後果可能會在軟件的完全不同的部分中表現出來。 由於您不知道應該責怪誰，因此您花費了大量時間進行調試。 最好在測試失敗時一次解決一個小錯誤，因為您會更好地了解真正的問題出在哪裡。 測試通常比調試更有趣，因為它是編碼。

### What kind of tests?
可以在任何軟件上進行多種測試。 主要的是驗收測試（或功能測試）和單元測試，這些是大多數人在討論軟件測試主題時想到的。 但是您可以在項目中使用其他幾種測試。 我們將在本節中很快討論其中的一些。
#### Accepetance tests 
驗收測試側重於功能並像黑盒子一樣處理軟件。 它只是確保軟件真正按照預期的方式工作，使用與用戶相同的媒體並控制輸出。 這些測試通常在開發週期之外編寫，以驗證應用程序是否滿足要求。 它們通常作為軟件的清單運行。 通常，這些測試不是通過 TDD 完成的，而是由經理、QA 人員甚至客戶構建的。 在那種情況下，它們通常被稱為用戶驗收測試。

不過，他們可以而且應該按照 TDD 原則來完成。 可以在編寫功能之前提供測試。 開發人員得到一堆驗收測試，通常由功能規範組成，他們的工作是確保代碼能夠通過所有這些測試。

#### Unit tests
單元測試是非常適合測試驅動開發的低級測試。 顧名思義，他們專注於測試軟件單元。 軟件單元可以理解為應用程序代碼的最小可測試部分。 根據應用程序的不同，大小可能會有所不同，從整個模塊到單個方法或函數，但通常會為盡可能小的代碼片段編寫單元測試。 單元測試通常將被測試單元（模塊、類、函數等）與應用程序的其餘部分和其他單元隔離開來。 當需要外部依賴項（例如 Web API 或數據庫）時，它們通常會被假對像或模擬所取代。

#### Functional tests
功能測試側重於整個特性和功能，而不是小的代碼單元。 它們的目的與驗收測試相似。 主要區別在於功能測試不一定需要使用與用戶相同的界面。 例如，在測試 Web 應用程序時，一些用戶交互（或其結果）可以通過合成 HTTP 請求或直接數據庫訪問來模擬，而不是模擬真實的頁面加載和鼠標點擊。

這種方法通常比使用用戶驗收測試中使用的工具進行測試更容易、更快速。 有限功能測試的缺點是它們往往無法覆蓋應用程序中不同抽象層和組件相遇的足夠部分。 專注於此類交匯點的測試通常稱為集成測試。

#### Integration tests

集成測試代表比單元測試更高級別的測試。 他們測試更大的代碼部分，並專注於許多應用程序層或
  
組件彼此相遇並相互作用。 集成測試的形式和範圍因項目的架構和復雜性而異。 例如，在小型單體項目中，這可能就像運行更複雜的功能測試一樣簡單，並允許它們與真正的支持服務（數據庫、緩存等）交互，而不是模擬或偽造它們。 對於由多個服務構建的複雜場景或產品，真正的集成測試可能非常廣泛，甚至需要在大型分佈式環境中運行整個項目，以反映生產。
#### Load and performance testing 
負載測試和性能測試提供有關代碼效率而非正確性的客觀信息。 負載測試和性能測試這兩個術語可以互換使用，但第一個實際上指的是性能的一個有限方面。 負載測試側重於測量代碼在某些人為需求（負載）下的行為方式。 這是一種非常流行的測試 Web 應用程序的方法，其中負載被理解為來自真實用戶或程序化客戶端的 Web 流量。 請務必注意，負載測試往往涵蓋對應用程序的整個請求，因此與集成和功能測試非常相似。 這使得確保測試的應用程序組件得到充分驗證以正常工作變得非常重要。 性能測試通常是所有旨在衡量代碼性能的測試，甚至可以針對小的代碼單元。 因此，負載測試只是性能測試的一個特定子類型。
#### Code quality testing 
代碼質量沒有可以確定是好是壞的任意尺度。 不幸的是，代碼質量這個抽象概念無法用數字的形式來衡量和表達。 但是相反，我們可以測量已知與代碼質量高度相關的軟件的各種指標。 舉幾個例子：
- 代碼風格違規次數
- 文件數量
- 複雜度指標，例如 McCabe 的圈複雜度 靜態代碼分析警告的數量
許多項目在其持續集成工作流中使用代碼質量測試。 好的和流行的方法是至少測試基本指標（靜態代碼分析和代碼風格違規），並且不允許將任何代碼合併到主流，從而降低這些指標。

### Python standard test tools
#### unittest
unittest 基本上提供了 JUnit 為 Java 做的事情。 它提供了一個稱為 TestCase 的基類，它有一組廣泛的方法來驗證函數調用和語句的輸出。
創建此模塊是為了編寫單元測試，但只要測試使用用戶界面，也可以用它編寫驗收測試。 例如，一些測試框架提供幫助程序來驅動單元測試之上的 Selenium 等工具。
使用 unittest 為模塊編寫簡單的單元測試是通過繼承 TestCase 並使用 test 前綴編寫方法來完成的。 
#### doctest
doctest 是一個模塊，它以交互式提示會話的形式從文檔字符串或文本文件中提取片段並重放它們以檢查示例輸出是否與真實輸出相同。


## I do test
如果您來自“我不測試”部分並且現在確信要進行測試驅動開發，那麼恭喜您！ 您了解測試驅動開發的基礎知識，但是在您能夠有效地使用這種方法之前，您還應該學習更多的東西。
本節介紹開發人員在編寫測試時遇到的一些問題以及解決這些問題的一些方法。 它還提供了對 Python 社區中可用的流行測試運行器和工具的快速回顧。

### unittest pitfalls
unittest 模塊是在 Python 2.1 中引入的，此後被開發人員大量使用。 但是一些替代測試框架是由對單元測試的弱點和局限性感到沮喪的人們在社區中創建的。
這些是經常被提出的常見批評：
- The framwork is heavy to use
- The framework is hard to extend because it requires massive subclassing of its base classes or tricks such as decorators
- Text fixtures are sometimes hard to organize because the setup and tearDown facilities are tired to the TextCase level,though they run once per test
- It is not easy to run a test campaign over python software

需要一種更輕鬆的方法來編寫測試，而不會受到框架的僵化的影響，該框架看起來太像它的大 Java 兄弟 JUnit。 由於 Python 不需要使用 100% 基於類的環境，因此最好提供一個不基於子類化的更 Pythonic 的測試框架。
一種常見的方法是：
- 提供一種將任何函數或任何類標記為測試的簡單方法
- 通過插件系統擴展框架
- 為所有測試級別提供完整的測試夾具環境：整個活動、模塊級別的一組測試和測試級別
- 為基於測試發現的測試運行器提供一組廣泛的選項

### unittest alternatives
一些第三方工具試圖通過以單元測試擴展的形式提供額外的特性來解決剛才提到的問題。
但只有兩個項目特別受歡迎：
- 鼻子：http://nose.readthedocs.org 
- py.test：http://pytest.org

#### nose 
nose 主要是一個具有強大發現功能的測試運行器。 它具有廣泛的選項，允許在 Python 應用程序中運行各種測試活動。
它不是標準庫的一部分，但在 PyPI 上可用，並且可以使用 pip 輕鬆安裝：
`pip install nose`
##### Test runner 
安裝 nose 後，一個名為 nosetests 的新命令在提示符下可用。 運行本章第一節中介紹的測試可以直接用它來完成：
##### Writing tests 
nose 更進一步，運行名稱與正則表達式 ((?:^|[b_.-])[Tt]est) 匹配的所有類和函數，這些類和函數也位於與其匹配的模塊中。 粗略地說，所有以 test 開頭並位於與模式匹配的模塊中的可調用項也將作為測試執行。

##### Writing test fixtures 
nose 支持三個級別的 fixtures：
- 包級別：可以在包含所有測試模塊的測試包的 __init__.py 模塊中添加設置和拆卸功能模塊級別：
- 測試模塊可以有自己的設置和拆卸功能
- 測試級別：可調用對像還可以使用提供的 with_setup 裝飾器具有固定功能

##### Intergration with setuptools and a plug-in system 
最後，nose 與 setuptools 順利集成，因此可以使用測試命令（python setup.py test）。這種集成是通過在 setup.py 腳本中添加 test_suite 元數據來完成的：

##### Wrap-up
nose 是一個完整的測試工具，可以解決 unittest 存在的許多問題。 它仍然被設計為使用隱式前綴名稱進行測試，這對一些開發人員來說仍然是一個限制。 雖然可以自定義此前綴，但它仍然需要遵循約定。
這種對配置語句的約定還不錯，比單元測試中所需的樣板代碼要好得多。 但是，例如，使用顯式裝飾器可能是擺脫測試前綴的好方法。

此外，使用插件擴展 nose 的能力使其非常靈活，並允許開發人員自定義工具以滿足他/她的需求。
如果您的測試工作流程需要覆蓋大量 nose 參數，您可以輕鬆地在主目錄或項目根目錄中添加 .noserc 或 nose.cfg 文件。 它將指定 nosetests 命令的默認選項集。 例如，一個好的做法是在測試運行期間自動查找 doctests。 啟用運行 doctests 的 nose 配置文件示例如下：
```
[nosetests]
with-doctest=1
doctest-exetension=.txt
```
#### py.test
py.test 與鼻子非常相似。 事實上，後者的靈感來自 py.test，因此我們將主要關注使這些工具彼此不同的細節。 該工具是作為名為 py 的更大包的一部分而誕生的，但現在它們是單獨開發的。
與本書中提到的每個第三方包一樣，py.test 在 PyPI 上可用，並且可以使用 pip 作為 pytest 安裝：
`pip install pytest`
從那裡，一個新的 py.- test 命令在提示符下可用，可以像 nosetests 一樣使用。 該工具使用類似的模式匹配和測試發現算法來捕獲要運行的測試。 該模式比 nose 使用的模式更嚴格，只會捕獲：
- 以 Test 開頭的類，在以 test 開頭的文件中 
- 以 test 開頭的函數，在以 test 開頭的文件中

##### Writing test fixtures
py.test 支持兩種機制來處理固定裝置。 第一個，仿照 xUnit 框架，類似於 nose。 當然語義有點不同。 py.test 將在每個測試模塊中查找三個級別的固定裝置，如下例所示：

每個函數都將獲取當前模塊、類或方法作為參數。 因此，測試夾具將能夠在上下文中工作而無需查找它，就像鼻子一樣。

用 py.test 編寫固定裝置的替代機制是建立在
依賴注入的概念，允許以更加模塊化和可擴展的方式維護測試狀態。 非 xUnit 風格的固定裝置（設置/拆卸過程）始終具有唯一的名稱，需要通過在類中的測試函數、方法和模塊中聲明它們的使用來顯式激活。

##### Disabling test functions and classess
py.test 提供了一種在特定條件下禁用某些測試的簡單機制。 這稱為跳過，pytest 包為此提供了 .skipif 裝飾器。 如果需要在某些條件下跳過單個測試函數或整個測試類裝飾器，則需要使用此裝飾器定義它，並提供一些值來驗證是否滿足預期條件。 這是官方文檔中的一個示例，它跳過了在 Windows 上運行整個測試用例類：
```python
import pytest
@pytest.mark.skipif(
    sys.platform=='win32',
    reason = 'does not run on windows'
)
class TestPosixCalls:
    def test_function(self):
        pass
        '''Will not be setup or run under win32 platform'''
```
使用 xfail 比 skipif 嚴格得多。 測試始終執行，如果它沒有按預期失敗，那麼整個 py.test 運行將導致失敗。
##### Automated distributed tests
py.test 的一個有趣特性是它能夠在多台計算機上分發測試。 只要計算機可以通過 SSH 訪問，py.test 就可以通過發送要執行的測試來驅動每台計算機。
但是，此功能依賴於網絡； 如果連接斷開，從站將無法繼續工作，因為它完全由主站驅動。
當項目具有長期測試活動時，Buildbot 或其他持續集成工具更可取。 但是當你在一個消耗大量資源來運行測試的應用程序上工作時，py.test 分佈式模型可以用於測試的臨時分佈。

##### Wrap-up
py.test 與 nose 非常相似，因為不需要樣板代碼來聚合其中的測試。 它還有一個很好的插件系統，並且 PyPI 上有大量可用的擴展。
最後，py.test 專注於使測試運行得更快，並且與該領域的其他工具相比確實更勝一籌。 另一個值得注意的特性是真正有助於管理可重用的夾具庫的原始夾具方法。 有些人可能會爭辯說其中涉及的魔法太多了，但它確實簡化了測試套件的開發。 

### Testing coverage
代碼覆蓋率是一個非常有用的指標，它提供了有關項目代碼測試情況的客觀信息。 它只是衡量在所有測試執行期間執行了多少行代碼和執行了哪些代碼行。 它通常以百分比表示，100% 的覆蓋率意味著在測試期間執行了每一行代碼。

最流行的代碼覆蓋工具稱為簡單覆蓋，可在 PyPI 上免費獲得。 使用非常簡單，僅包含兩個步驟。 第一步是在 shell 中運行 coverage run 命令，並將運行所有測試的腳本/程序的路徑作為參數：

您應該記住，雖然您應該始終努力確保 100% 的測試覆蓋率，但這永遠不能保證代碼經過完美測試並且沒有任何地方可以破壞代碼。 這僅意味著在執行過程中到達了每一行代碼，但不一定測試了所有可能的條件。 在實踐中，確保代碼完全覆蓋可能相對容易，但要確保代碼的每個分支都被覆蓋確實很難。 對於可能具有 if 語句和特定語言結構（如列表/字典/集合理解）的多種組合的函數測試尤其如此。 你應該始終關心良好的測試覆蓋率，但你永遠不應該將它的測量作為你的測試套件有多好的最終答案。

### Fakes and mocks 
編寫單元測試的前提是您隔離了正在測試的代碼單元。 測試通常為函數或方法提供一些數據，並驗證其返回值和/或其執行的副作用。 這主要是為了確保測試：
- 涉及應用程序的原子部分，可以是函數、方法、類或接口
- 提供確定性、可重現的結果
有時，程序組件的適當隔離並不明顯。 例如，如果代碼發送電子郵件，它可能會調用 Python 的 smtplib 模塊，該模塊將通過網絡連接與 SMTP 服務器一起工作。 如果我們希望我們的測試是可重現的並且只是測試電子郵件是否具有所需的內容，那麼這可能不應該發生。 理想情況下，單元測試應該在沒有外部依賴性和副作用的任何計算機上運行。
由於 Python 的動態特性，可以使用猴子補丁從測試夾具修改運行時代碼（即，在運行時動態修改軟件而不觸及源代碼）來偽造第三方代碼或庫的行為。

#### Building a fake 
可以通過發現測試代碼與外部部件一起工作所需的最小交互集來創建測試中的虛假行為。 然後，手動返回輸出或使用先前記錄的真實數據池。

這是通過啟動一個空類或函數並將其用作替換來完成的。 然後啟動測試，並迭代更新假的，直到它的行為正確。 由於 Python 類型系統的性質，這是可能的。 只要該對象的行為符合預期類型並且不需要通過子類化成為其祖先，就認為該對象與給定類型兼容。 這種在 Python 中輸入的方法稱為鴨子類型——如果某物表現得像鴨子，它就可以像鴨子一樣對待。

你應該知道假貨有真正的局限性。 如果您決定偽造外部依賴項，則可能會引入真實服務器不會有的錯誤或不需要的行為，反之亦然。

#### Using mocks 
模擬對像是通用的假對象，可用於隔離測試代碼。 它們使對象輸入和輸出的構建過程自動化。 在靜態類型語言中更多地使用模擬對象，其中猴子修補更難，但它們在 Python 中仍然有用，可以縮短代碼以模仿外部 API。

Python 中有很多可用的模擬庫，但最受認可的是標準庫中提供的 unittest.mock。 它是作為第三方包創建的，而不是作為 Python 發行版的一部分，但很快作為臨時包包含在標準庫中（請參閱 https://docs.python.org/dev/glossary.html#term - 臨時 api）。 對於早於 3.3 的 Python 版本，您需要從 PyPI 安裝它：

### Testing environment and dependency compatibility
環境隔離的重要性在本書中已經多次提到。 通過在應用程序級別（虛擬環境）和系統級別（系統虛擬化）上隔離您的執行環境，您可以確保您的測試在可重複的條件下運行。 通過這種方式，您可以保護自己免受因破壞依賴關係而導致的罕見和模糊問題的影響。

允許正確隔離測試環境的最佳方法是使用支持系統虛擬化的良好持續集成系統。 Travis CI（Linux 和 OS X）或 AppVeyor（Windows）等開源項目有很好的免費解決方案，但如果您需要這樣的東西來測試專有軟件，您很可能需要花一些時間 在一些現有的開源 CI 工具（GitLab CI、Jenkins 和 Buildbot）之上自行構建這樣的解決方案。

#### Dependency matrix testing 
大多數情況下，開源 Python 項目的測試矩陣只關注不同的 Python 版本，很少關注不同的操作系統。 對於純 Python 且沒有預期的系統互操作性問題的項目，不在不同系統上進行測試和構建是完全可以的。 但是有些項目，尤其是作為編譯後的 Python 擴展分發時，絕對應該在各種目標操作系統上進行測試。 對於開源項目，您甚至可能被迫使用幾個獨立的 CI 系統來為三個最流行的系統（Windows、Linux 和 Mac OS X）提供構建。 如果您正在尋找一個很好的示例，您可以查看小的 pyrilla 項目（請參閱 https://github.com/swistakm/pyrilla），它是一個簡單的 Python C 音頻擴展。 它使用 Travis CI 和 AppVeyor 來為 Windows 和 Mac OS X 以及大量的 CPython 版本提供編譯構建。


Tox 很棒，但如果我們想更改測試環境中不是普通 Python 依賴項的其他元素，它的使用會變得更加複雜。 這是我們需要在不同版本的系統包和支持服務下進行測試的情況。 解決這個問題的最好方法還是使用良好的持續集成系統，它允許您輕鬆定義環境變量矩陣並在虛擬機上安裝系統軟件。 ianitor 項目（請參閱 https://github.com/ClearcodeHQ/ianitor/）提供了使用 Travis CI 執行此操作的一個很好的示例，該項目已在第 9 章“記錄您的項目”中提到。 它是 Consul 發現服務的一個簡單實用程序。 Consul 項目有一個非常活躍的社區，每年都會發布許多新版本的代碼。 這使得針對該服務的各種版本進行測試變得非常合理。 這確保了 ianitor 項目仍然與該軟件的最新版本保持同步，但也不會破壞與以前的 Consul 版本的兼容性。 以下是 Travis CI 的 .travis.yml 配置文件的內容，它允許您針對三個不同的 Consul 版本和四個 Python 解釋器版本進行測試：

### Document-driven development
與其他語言相比，doctests 在 Python 中是一個真正的優勢。 事實上，文檔可以使用代碼示例，這些代碼示例也可以作為測試運行，這改變了 TDD 的完成方式。 例如，一部分文檔可以在開發週期中通過 doctests 完成。 這種方法還確保提供的示例始終是最新的並且真正有效。
通過 doctests 而不是常規單元測試構建軟件稱為文檔驅動開發（DDD）。 開發人員在實施代碼時用通俗易懂的語言解釋代碼的作用。

#### Writiing a story
在 DDD 中編寫 doctests 是通過構建一個關於一段代碼如何工作和應該如何使用的故事來完成的。 這些原則以通俗易懂的英語進行了描述，然後在整個文本中分發了一些代碼使用示例。 一個好的做法是開始編寫有關代碼如何工作的文本，然後添加一些代碼示例。
要查看實踐中的 doctests 示例，讓我們看一下 atomisator 包（請參閱 https://bitbucket.org/tarek/atomisator）。 其 atomisator.parser 子包（在 packages/atomisator.parser/atomisator/parser/docs/README.txt 下）


