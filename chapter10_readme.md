# Test-Driven Development
測試驅動開發 (TDD) 是一種生產高質量軟件的簡單技術。 它在 Python 社區中被廣泛使用，但在其他社區中也很受歡迎。

## I don't test
由於 Python 的動態特性，測試在 Python 中尤為重要。 它缺少靜態類型，因此在運行代碼並執行其每一行之前，許多甚至是微小的錯誤都不會被注意到。 但問題不僅在於 Python 中的類型如何工作。 請記住，大多數錯誤與錯誤的語法使用無關，而是與可能導致重大失敗的邏輯錯誤和微妙的誤解有關。

### Test-driven development principles 
以最簡單的形式，測試驅動開發過程包括三個步驟：
1. 為尚未實現的新功能或改進編寫自動化測試。
2. 提供剛好通過所有定義測試的最少代碼。 
3. 重構代碼以滿足所需的質量標準。
關於這個開發週期要記住的最重要的事實是測試應該在實現之前編寫。 對於沒有經驗的開發人員來說，這不是一件容易的事，但這是保證您將要編寫的代碼可測試的唯一方法。

測試驅動開發提供了很多好處：
- 它有助於防止軟件回歸
- 它提高了軟件質量
- 它提供了一種代碼行為的低級文檔
- 它允許您在較短的開發週期內更快地生成健壯的代碼
處理測試的最佳約定是將它們全部收集在一個模塊或包中（通常命名為測試），並有一種使用單個 shell 命令運行整個套件的簡單方法。 幸運的是，沒有必要自己構建整個測試工具鏈。 Python 標準庫和 Python Package Index 都帶有大量測試框架和實用程序，可讓您以方便的方式構建、發現和運行測試。 我們將在本章後面討論此類包和模塊的最著名示例。

#### Preventing software regression
在我們的開發人員生活中，我們都面臨著軟件回歸問題。 軟件回歸是由變更引入的新錯誤。 當已知在以前版本的軟件中工作的特性或功能在項目開發過程中的某個時刻被破壞並停止工作時，它就會出現。

回歸的主要原因是軟件的高度複雜性。 在某些時候，不可能猜測代碼庫中的單個更改可能導致什麼。 更改某些代碼可能會破壞其他一些功能，有時會導致惡性副作用，例如無聲地破壞數據。 而高複雜性不僅僅是龐大代碼庫的問題。 當然，代碼量與其複雜性之間存在明顯的相關性，但即使是小項目（幾百分之幾/幾千行代碼）也可能具有如此復雜的架構，以至於很難預測相對較小的變化的所有後果。

向多個開發人員開放代碼庫會放大問題，因為每個人都不會完全了解所有開發活動。 雖然擁有版本控制系統可以防止衝突，但它並不能防止所有不需要的交互。

TDD 有助於減少軟件回歸。 整個軟件可以在每次更改後自動測試。 只要每個功能都有適當的測試集，這就會起作用。 正確完成 TDD 後，測試庫會與代碼庫一起增長。

由於完整的測試活動可能會持續很長時間，因此最好將其委託給一些可以在後台完成工作的持續集成系統。 
#### Improving code quality
編寫新模塊、類或函數時，開發人員關注的是如何編寫它以及如何生成他或她所能編寫的最佳代碼。 但是當他或她專注於算法時，他或她可能會失去用戶的觀點：他或她的功能將如何以及何時被使用？ 這些論點是否易於使用且合乎邏輯？ API的名稱是否正確？
這是通過應用前面章節中描述的技巧來完成的，例如第 4 章，選擇好名字。 但唯一有效地做到這一點的方法是編寫使用示例。 這是開發人員意識到他或她編寫的代碼是否合乎邏輯且易於使用的時刻。 通常，第一次重構發生在模塊、類或函數完成之後。

#### Providing the best developer documentation
測試是開發人員了解軟件工作原理的最佳場所。 它們是代碼主要針對的用例。 閱讀它們可以快速深入地了解代碼的工作原理。 有時一個例子勝過一千個字。
事實上，這些測試始終與代碼庫保持同步，這使它們成為軟件可以擁有的最好的開發人員文檔。 測試不會像文檔那樣過時，否則它們會失敗。

#### Producing robust code faster 
未經測試而編寫會導致調試時間過長。 一個模塊中錯誤的後果可能會在軟件的完全不同的部分中表現出來。 由於您不知道應該責怪誰，因此您花費了大量時間進行調試。 最好在測試失敗時一次解決一個小錯誤，因為您會更好地了解真正的問題出在哪裡。 測試通常比調試更有趣，因為它是編碼。

### What kind of tests?
可以在任何軟件上進行多種測試。 主要的是驗收測試（或功能測試）和單元測試，這些是大多數人在討論軟件測試主題時想到的。 但是您可以在項目中使用其他幾種測試。 我們將在本節中很快討論其中的一些。
#### Accepetance tests 
驗收測試側重於功能並像黑盒子一樣處理軟件。 它只是確保軟件真正按照預期的方式工作，使用與用戶相同的媒體並控制輸出。 這些測試通常在開發週期之外編寫，以驗證應用程序是否滿足要求。 它們通常作為軟件的清單運行。 通常，這些測試不是通過 TDD 完成的，而是由經理、QA 人員甚至客戶構建的。 在那種情況下，它們通常被稱為用戶驗收測試。

不過，他們可以而且應該按照 TDD 原則來完成。 可以在編寫功能之前提供測試。 開發人員得到一堆驗收測試，通常由功能規範組成，他們的工作是確保代碼能夠通過所有這些測試。

#### Unit tests
單元測試是非常適合測試驅動開發的低級測試。 顧名思義，他們專注於測試軟件單元。 軟件單元可以理解為應用程序代碼的最小可測試部分。 根據應用程序的不同，大小可能會有所不同，從整個模塊到單個方法或函數，但通常會為盡可能小的代碼片段編寫單元測試。 單元測試通常將被測試單元（模塊、類、函數等）與應用程序的其餘部分和其他單元隔離開來。 當需要外部依賴項（例如 Web API 或數據庫）時，它們通常會被假對像或模擬所取代。

#### Functional tests
功能測試側重於整個特性和功能，而不是小的代碼單元。 它們的目的與驗收測試相似。 主要區別在於功能測試不一定需要使用與用戶相同的界面。 例如，在測試 Web 應用程序時，一些用戶交互（或其結果）可以通過合成 HTTP 請求或直接數據庫訪問來模擬，而不是模擬真實的頁面加載和鼠標點擊。

這種方法通常比使用用戶驗收測試中使用的工具進行測試更容易、更快速。 有限功能測試的缺點是它們往往無法覆蓋應用程序中不同抽象層和組件相遇的足夠部分。 專注於此類交匯點的測試通常稱為集成測試。

#### Integration tests

集成測試代表比單元測試更高級別的測試。 他們測試更大的代碼部分，並專注於許多應用程序層或
  
組件彼此相遇並相互作用。 集成測試的形式和範圍因項目的架構和復雜性而異。 例如，在小型單體項目中，這可能就像運行更複雜的功能測試一樣簡單，並允許它們與真正的支持服務（數據庫、緩存等）交互，而不是模擬或偽造它們。 對於由多個服務構建的複雜場景或產品，真正的集成測試可能非常廣泛，甚至需要在大型分佈式環境中運行整個項目，以反映生產。
#### Load and performance testing 
負載測試和性能測試提供有關代碼效率而非正確性的客觀信息。 負載測試和性能測試這兩個術語可以互換使用，但第一個實際上指的是性能的一個有限方面。 負載測試側重於測量代碼在某些人為需求（負載）下的行為方式。 這是一種非常流行的測試 Web 應用程序的方法，其中負載被理解為來自真實用戶或程序化客戶端的 Web 流量。 請務必注意，負載測試往往涵蓋對應用程序的整個請求，因此與集成和功能測試非常相似。 這使得確保測試的應用程序組件得到充分驗證以正常工作變得非常重要。 性能測試通常是所有旨在衡量代碼性能的測試，甚至可以針對小的代碼單元。 因此，負載測試只是性能測試的一個特定子類型。
#### Code quality testing 
代碼質量沒有可以確定是好是壞的任意尺度。 不幸的是，代碼質量這個抽象概念無法用數字的形式來衡量和表達。 但是相反，我們可以測量已知與代碼質量高度相關的軟件的各種指標。 舉幾個例子：
- 代碼風格違規次數
- 文件數量
- 複雜度指標，例如 McCabe 的圈複雜度 靜態代碼分析警告的數量
許多項目在其持續集成工作流中使用代碼質量測試。 好的和流行的方法是至少測試基本指標（靜態代碼分析和代碼風格違規），並且不允許將任何代碼合併到主流，從而降低這些指標。

### Python standard test tools
#### unittest
unittest 基本上提供了 JUnit 為 Java 做的事情。 它提供了一個稱為 TestCase 的基類，它有一組廣泛的方法來驗證函數調用和語句的輸出。
創建此模塊是為了編寫單元測試，但只要測試使用用戶界面，也可以用它編寫驗收測試。 例如，一些測試框架提供幫助程序來驅動單元測試之上的 Selenium 等工具。
使用 unittest 為模塊編寫簡單的單元測試是通過繼承 TestCase 並使用 test 前綴編寫方法來完成的。 
#### doctest
doctest 是一個模塊，它以交互式提示會話的形式從文檔字符串或文本文件中提取片段並重放它們以檢查示例輸出是否與真實輸出相同。


## I do test
如果您來自“我不測試”部分並且現在確信要進行測試驅動開發，那麼恭喜您！ 您了解測試驅動開發的基礎知識，但是在您能夠有效地使用這種方法之前，您還應該學習更多的東西。
本節介紹開發人員在編寫測試時遇到的一些問題以及解決這些問題的一些方法。 它還提供了對 Python 社區中可用的流行測試運行器和工具的快速回顧。

### unittest pitfalls
unittest 模塊是在 Python 2.1 中引入的，此後被開發人員大量使用。 但是一些替代測試框架是由對單元測試的弱點和局限性感到沮喪的人們在社區中創建的。
這些是經常被提出的常見批評：
- The framwork is heavy to use
- The framework is hard to extend because it requires massive subclassing of its base classes or tricks such as decorators
- Text fixtures are sometimes hard to organize because the setup and tearDown facilities are tired to the TextCase level,though they run once per test
- It is not easy to run a test campaign over python software

需要一種更輕鬆的方法來編寫測試，而不會受到框架的僵化的影響，該框架看起來太像它的大 Java 兄弟 JUnit。 由於 Python 不需要使用 100% 基於類的環境，因此最好提供一個不基於子類化的更 Pythonic 的測試框架。
一種常見的方法是：
- 提供一種將任何函數或任何類標記為測試的簡單方法
- 通過插件系統擴展框架
- 為所有測試級別提供完整的測試夾具環境：整個活動、模塊級別的一組測試和測試級別
- 為基於測試發現的測試運行器提供一組廣泛的選項

### unittest alternatives
一些第三方工具試圖通過以單元測試擴展的形式提供額外的特性來解決剛才提到的問題。
但只有兩個項目特別受歡迎：
- 鼻子：http://nose.readthedocs.org 
- py.test：http://pytest.org

#### nose 
nose 主要是一個具有強大發現功能的測試運行器。 它具有廣泛的選項，允許在 Python 應用程序中運行各種測試活動。
它不是標準庫的一部分，但在 PyPI 上可用，並且可以使用 pip 輕鬆安裝：
`pip install nose`
##### Test runner 
安裝 nose 後，一個名為 nosetests 的新命令在提示符下可用。 運行本章第一節中介紹的測試可以直接用它來完成：
##### Writing tests 
nose 更進一步，運行名稱與正則表達式 ((?:^|[b_.-])[Tt]est) 匹配的所有類和函數，這些類和函數也位於與其匹配的模塊中。 粗略地說，所有以 test 開頭並位於與模式匹配的模塊中的可調用項也將作為測試執行。

##### Writing test fixtures 
nose 支持三個級別的 fixtures：
- 包級別：可以在包含所有測試模塊的測試包的 __init__.py 模塊中添加設置和拆卸功能模塊級別：
- 測試模塊可以有自己的設置和拆卸功能
- 測試級別：可調用對像還可以使用提供的 with_setup 裝飾器具有固定功能

##### Intergration with setuptools and a plug-in system 
最後，nose 與 setuptools 順利集成，因此可以使用測試命令（python setup.py test）。這種集成是通過在 setup.py 腳本中添加 test_suite 元數據來完成的：

##### Wrap-up
nose 是一個完整的測試工具，可以解決 unittest 存在的許多問題。 它仍然被設計為使用隱式前綴名稱進行測試，這對一些開發人員來說仍然是一個限制。 雖然可以自定義此前綴，但它仍然需要遵循約定。
這種對配置語句的約定還不錯，比單元測試中所需的樣板代碼要好得多。 但是，例如，使用顯式裝飾器可能是擺脫測試前綴的好方法。

此外，使用插件擴展 nose 的能力使其非常靈活，並允許開發人員自定義工具以滿足他/她的需求。
如果您的測試工作流程需要覆蓋大量 nose 參數，您可以輕鬆地在主目錄或項目根目錄中添加 .noserc 或 nose.cfg 文件。 它將指定 nosetests 命令的默認選項集。 例如，一個好的做法是在測試運行期間自動查找 doctests。 啟用運行 doctests 的 nose 配置文件示例如下：
```
[nosetests]
with-doctest=1
doctest-exetension=.txt
```
#### py.test

##### Writing test fixtures
##### Disabling test functions and classess
##### Automated distributed tests
##### Wrap-up

### Testing coverage
### Fakes and mocks 
#### Building a fake 
#### Using mocks 
### Testing environment and dependency compatibility
#### Dependency matrix testing 
### Document-driven development
#### Writiing a story

